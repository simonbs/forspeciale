\section{Schedulers}\label{sec:schedimpl}
This section will describe the implementation of our scheduling models. Each model will have a separate section, describing how they overall were implemented and may include some code snippets of interesting or important code. However, before we get to the different models, we introduce our scheduling interface that describes the general scheduling implementation.

\subsection{Scheduler Interface}
The scheduler interface is a collection of methods, which all the scheduling models must implement. This makes using different schedulers vastly easier, which is helpful when evaluating and comparing performance. \Cref{lst:schedulerinterface} shows the essential method required for scheduling to work.

\lstinputlisting[caption={Scheduler interface}, label={lst:schedulerinterface}]{listings/schedulerInterface.java}

This interface is implemented by both scheduling models. The \texttt{ChargePlan} is a data structure we use to represent a schedule, and was introduced in \Cref{chap:design}. It consists of two \texttt{List}s, one for energy imports\slash exports and a \texttt{List} of \texttt{List}s, where the outer list represent time slots and the inner list contains charge-offers. In the implementation we have split the implementation of charge-context, into the three lists: \texttt{List<ChargeOffer> offers}, \texttt{List<Power> production} and \texttt{List<Cash> prices}.

\subsection{Greedy Scheduler}
The greedy scheduler is trivially implemented using \Cref{alg:greedy} designed in \Cref{sec:greedyschedanal}. The for-loop is replaced with three similar for-loops, that each run through the time slots. This is convenience and to properly schedule charge-offers in each time slot. The time complexity does however not change. %Thalley - Skal vi beregne den som forklaring?

\subsection{Linear Programming Scheduler}
The LP scheduler as designed in \Cref{sec:lpsched} consists of three steps, and uses a linear programming tool. The LP tool used is the GNU Linear Programming Kit (GLPK). GLPK is intended for solving large-scale LP problems, mixed integer programming problems, and other related problems. GLPK supports MathProg, a subset of the modeling language AMPL. 

The implementation of GLPK in our system follows the design approach described in \Cref{sec:lpsched}. The first step is generating an input table like described in \Cref{sec:idea}. The actual implementation of this table is a little different than originally designed, due to the limits of GLPK. The matrix idea is still the same, however the production data is stored in a separate list: \var{EP}. The input file also contains lists describing minimum and maximum amounts of energy needed by all charge-offers, and a list of import and export prices. All this data is stored in a data file used by GLPK, as shown in \Cref{lst:lpschinp} below:  

\lstinputlisting[caption={Lpschedule.dat example from \Cref{tab:unsched}}, label={lst:lpschinp}, language={AMPL}]{listings/lpschedule.dat}

Generating the above input matrix \var{chargeContext}, is done by simply running a nested loop over the charge-offers and the time slots they can be scheduled in. Since this scheduler, like the other scheduler implements the \var{Scheduler} interface, it receives this information upon scheduling.

The generated data file is given to a model file, shown below. The model file includes the description of the optimization problem and its constraints. GLPK loads the data from the .dat file parameters to this model. Besides the parameters given in data file, our model file also uses the 2 unknown factors first mentioned in \Cref{sec:optimizationProblem}: energy import and a table as shown in \Cref{sec:lpsched}.

The objective function and constraints are slightly different from the optimization problem in \Cref{eq:opprob}. The difference is that energy exports are left out. Exported energy is left out of the equation, because it is easily calculated when energy imports is known. \var{chargeOffers} is the set of charge-offers given to the model and \var{timeSlots} is the set of time slots. \var{chargeContext} is the input table like \Cref{tab:unsched} and \var{chargePlan} is the output table \Cref{tab:sched}. \var{EI} and \var{chargePlan} are the unknown variables. The model file is shown below in \Cref{lst:glpkmodel}:

\lstinputlisting[caption={GLPK model file, without prints and params}, label={lst:glpkmodel}, language={AMPL}]{listings/lpmodel.mod}
Having a data file and a model file, we can now call GLPK to solve our objective function. 

Upon calling GLPK, we use the compiler flag \texttt{--nomip} to tell GLPK to not interpret the problem as a mixed integer programming problem, described in \Cref{sec:lpsched}. When GLPK is done, the data in the output charge-plan is rounded to ones or zeros by the system before it can be read back to create a complete schedule. The output is read back to the system via a single loop.

